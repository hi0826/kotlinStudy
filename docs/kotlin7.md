# 객체지향의 기본

## 클래스와 객체의 정의
- 절차식에서 같은 패턴이 나타남
    - 구조적으로 어떻게 바꿀 수 있을까?
    - 객체지향형
- OOP (Object Oriented Programming)
    - 프로그램의 구조를 객체간 상호작용으로서 표현
    - 객체와 관계를 표현하고 이를 통해 확장과 재사용이 용이
    - C 의 구조체를 발전시켜서 class로 만듬
- 객체지향의 기본 용어
    - 추상화
        - 어떤 내용을 개념화
    - 인스턴스
        - 추상화 된 것을 실제로 만들어 줌
    - 상속
        - 추상화 된 개념에서 더 분류화시키는 작업
    - 다형성
        - 어떠한 action을 하나가 아닌 개념에 맞게 표현할 수 있음
    - 캡슐화
        - 특정 내용을 숨기고 필요한 부분만 접근하게끔 하는 것
    - 메시지 전송
        - 만들어진 객체간 서로 데이터를 주고받는 
    - 연관
        - 객체간 특정 관계
- class
    - 특정 대상을 분류하고 특징(속성)과 동작(함수)을 정의 한다
    - 실체화 되지 않은 어떠한 개념
    - 메모리상 존재하지 않음
- 추상화
    - 목표로 하는 것에 대해 속성과 동작을 정의하는 것
    - class

## 생성자
- 클래스를 통해 객체가 만들어질 때 기본적으로 호출되는 함수
- 생성자를 위해 특별한 함수인 constructor()를 정의
- 주 생성자는 [클래스 이름] 옆에 constructor(매개변수)로 정의
- 부 생성자는 추가로 내부에 constructor 키워드를 통해 정의

### 생성자의 정의
- 주 생성자
    - 클래스명과 함께 기술, 보통의 경우 constructor 키워드를 생략할 수 있다
- 부 생성자
    - 클래스 본문에 기술되며 하나 이상의 부 생성자를 정의할 수 있다.
    
## 상속
- 상위 클래스의 속성과 기능을 물려받아 사용
- 상위 클래스의 프로퍼티와 메서드가 하위 클래스에 적용
- 코틀린의 최상위 클래스는 `Any`   
    - kotlin의 모든 클래스는 기본적으로 상속
- 상위 클래스로 만들기 위해서는 `open` 키워드 사용
- `class [ClassName]: [UpperName](상위 클래스 생성자) { ... }`
    - 최종 클래스, 하부로 파생될 수 없는 상태
    - `open`이 붙는다면 파생할 수 있음

### 다형성(Polymorphism)
- 한 가지의 형태로 다수의 일을 수행한다는 의미
- 같은 이름이지만 다른 일을 수행
- static polymorphism   
    - 컴파일 타임에 결정되는 다형성
    - 오버로딩을 사용할 때
- dynamic polymorphism
    - 런타임
    - 오버라이딩을 사용할 때
- 오버라이딩
    - 기능을 완전히 다르게 바꾸어 재설계
    - property, method 앞에 open 사용하기
    
## super와 this의 참조
- 상위 클래스는 super로 접근 가능
- 현재 클래스는 this로 접근 가능

### @ 기호를 통해서 특정 클래스 지정 가능
### \<>앵클브라켓 사용

## 캡슐화
- 클래스를 작성할 때 외부에서 숨겨야 하는 속성이나 기능
- 가시성 지시자(visibility modifiers)를 통해 외부 접근 범위를 결정할 수 있음
  - private: 외부에서 접근 불가능
  - public: 어디서든 접근 가능
  - protected: 외부에서 접근할 수 없으나 상속 요소에서는 가능
  - internal: 같은 정의의 모듈 내부에서는 접근 가능
    - 자바에서는 package 를 사용하지만, 코틀린은 internal
  - 전역변수, 함수, 클래스, 클래스 프로 퍼티, 메서드, 생성자 등에 붙일 수 있음 
  
## 클래스와 관계
- 일반적인 실세계의 관계
### 관계
- 연관
  - 0 : n의 관계
- 의존
  - 의존되는 객체를 정해주는 경우
- 집합
  - 어떤것 하나에 다수의 관계가 포함되는 경우
- 구성
  - 하나의 부품으로 존재
### 관계 판별법
- 참조유지 Y > 연관
- 참조유지 N > 의존
- 생명주기 Y > 집합
- 생명주기 N > 구성

## 객체간 메세지 전달
- 