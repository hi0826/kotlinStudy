# 추상 클래스

- 구현 클래스에서 가져야할 명세를 정의한 클래스
- abstract라는 키워드와 함께 선언, 추상클래스는 객체 생성 안됨
- 구체적이지 않은 것을 나타내기 때문에 하위 파생 클래스에서 구체적으로 구현
- `abstract class Vehicle`
- open 키워드를 사용하지 않고도 파생 클래스 작성 가능
- 비추상 프로퍼티는 사용해도되고 안해도 됨
- 추상 프로퍼티는 꼭 재정의해서 초기화 할 것
- 추상 메서드는 꼭 재정의해야한다
- `object`라는 키워드를 사용하면 추상 클래스로부터 하위 클래스를 생성하지 않고 인스턴스로 객체 생성이 가능

# 인터페이스

- 계약서와 같은 내용
  - ~~을 하라는 추상적인 활동들
  - 계약서 자체로는 실행될 수 없음
- 추상 클래스와 다른 점
  - 클래스가 아니므로 여러개를 구현할 수 있음
  - 클래스는 다중 상속을 지원하지 않는다
  - 강한 연관을 가지지 않음(추상 클래스는 강한 연관)
- 코틀린의 인터페이스
  - `interface 키워드를 사용해 정의`
  - 인터페이스는 기본적으로 추상 메서드가 됨
  - 구현 내용이 표현 가능하다
    - 자바에서는 default를 사용했어야함(java 8)
  - override를 사용해서 해당 메서드를 구현
- 인터페이스에서 프로퍼티에 값을 저장할 수 없지만, val 선언의 경우 게터를 통해 필요한 내용을 구현할 수 있음
- 인터페이스의 위임
  - 인터페이스의 일반 메서드가 있는 경우
  - 다른 클래스에서 인터페이스를 프로퍼티로 받아서 특정 메서드에서 실행 시킴

# 데이터 전달을 위한 데이터 클래스

- 데이터 전달을 위한 객체 DTO(Data Transfer Object)
  - java 에서는 POJO(Plain Old Java Object)
  - 구현 로직을 가ㅣㅈ고 있지 않음, 순수한 데이터 객체를 표현
  - getter, setter 포함
  - toString, equal 같은 데이터 표현 및 비교 메서드 포함
  - 코틀리는 프로퍼티만 신경써서 만들어주면 다른 것들은 자동 생성해준다.

## 코틀린의 데이터 클래스

- data class 키워드를 사용해 정의
- 게터, 세터, equals, hashCode, toString, copy, component1, component2 등 메서드 자동생성 지원

## 데이터 클래스 선어

- `data class Customer(var name: String, var email: String)`
- 데이터 클래스의 조건
  - 주 생성자는 최소한 하나의 매개변수를 가져야 한다.
  - 주 생성자의 모든 매개변수는 val, var로 지정된 프로퍼티여야함
  - 데이터 클래스는 abstract, open, sealed, inner 키워드를 사용할 수 없다
  - "부 생성자"나 "init" 블록을 넣어 데이터를 위한 간단한 로직을 포함할 수 있다
- hashCode > 고유값을 나타낸다

## 객체 디스트럭처링

- 객체가 가지고 있는 프로퍼티들을 개별 변수들로 분해
  - `val (name, email) = cus1`
- 특정 프로퍼티를 가져올 필요 없는 경우
  - `val (_, email) = cus1`
- for 를 사용해서도 가져올 수 있음
- 함수로부터 객체가 반환될 경우
  - `val (myName, myEmail) = myFunc()`
- 람다식에서 사용하는 경우

```kotlin
val myLambda = {
  (nameLa, emailLa): Customer ->
  println(nameLa)
  println(emailLa)
}
myLambda(cus1)
```

# 내부 클래스와 중첩 클래스

- nested, inner 두가지 종류가 있음
- 중첩 클래스(nested)
  - 객체 생성없이 사용 가능
  - 자바의 정적 클래스 처럼 사용하게됨
- 이너 클래스
  - 필드나 메서드와 연동하는 내부 클래스로 inner 키워드가 필요하다

## 중첩 클래스

- 코틀린에서 중첩 클래스는 기본적으로 정적(static) 클래스처럼 다뤄진다
- companion 객체를 가지고 있을 때 접근 가능하다

## 이너 클래스

- 특별한 키워드인 inner를 사용해 선언된 내부 클래스
- 이너 클래스는 바깥 클래스의 멤버들에 접근 가능
- 바깥 클래스의 private 멤버도 접근 가능

## 지역 클래스

- 특정 메서드 블럭이나 init 블록과 같이 블록 범위에서만 유효한 클래스

## 익명 클래스

- 일회성으로 객체를 한 번 생성해서 사용하기 위해 있음
- 메모리 효율적, 빠르게 프로그래밍 가능
- object 키워드를 사용해 익명 객체로 같은 기능 수행

## 실드 클래스(Sealed)

- 무언가 안전하게 보관하기 위해 묶어 두는 것
- sealed 키워드 사용
- 추상클래스와 같기 때문에 객체를 만들 수는 없음
- 생성자도 기본적으로 private
- 같은 파일 안에서는 상속 가능
- 블록 안에 선언되는 클래스는 상속이 필요한 경우 open 키워드로 선언

## 열거형 클래스

- 여러 개의 상수를 연결할 때
- 자료형이 동일한 것들
- `enum`키워드 사용
- 메서드 포함 가능

## 애노테이션(annotation)

- 코드에 부가정보를 추가하는 기능 역할
- @ 기호와 함께 나타내는 표기법, 컴파일러나 프로그램 실행 시간에서 사전 처리를 위해 사용
- `annotation class [어노테이션명]`
- 속성
  - @Target
    - 어노테이션이 지정되어 사용할 종류
  - @Retention
    - 어노테이션을 컴파일된 클래스 파일에 저장할 것인지, 런타임에 반영할 것인지
  - @Repeatable
    - 어노테이션을 같은 요소에 여러 번 사용 가능하게 할지
  - @MustBeDocumted
    - 어노테이션이 API 일부분으로 문서화하기 위해 사용

## 연산자 오버로딩

- 연산자에 여러가지 다른 의미의 작동을 부여
- operator 키워드를 사용
- 코틀린에서는 특정 연산자의 역할을 함수로 정의
- 호출 연산자(invoke)
  - 함수 호출을 돕는데 사용
