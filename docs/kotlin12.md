# 동시성 프로그래밍

- 동기적 수행
  - 순서대로 작업을 수행하여 하나의 루틴을 완료한 후 다른 루틴을 실행하는 방식
  - 다양한 기능이 한꺼번에 일어나는 다중 실행 환경에선느 성능상의 제약 발생
- 비동기적 수행
  - 다양한 기능을 동시에 수행
  - RxJava, Reactive 와 같은 서드파티 라이브러리에서 제공
  - 코틀린에서는 코루틴을 기본으로 제공

## 코루틴

- 코루틴을 사용하면 넌블로킹 또는 비동기 코들르 마치 일반적인 동기 코드처럼 쉽게 잓어하면서도 비동기 효과를 낼 수 있다.

## 프로세스와 스레드

- 프로세스
  - 프로그램이 메모리(RAM)에 올라가서 run중인 상태
- 스레드(태스크)
  - 프로세스 내부에서 돌고있는 흐름
  - 프로세스는 실행되는 메모리, 스택, 파일등을 포함하여 프로세스간 context switching 교환 비용이 큼
  - 스레드는 자신의 스택만 독립적으로 가지고 나머지는 대부분 공유, 문맥 교환 비용이 낮아 프로그래밍에서 많이 사용
    - 스레드 구성이 많아지면 코드가 복잡해진다.

### 문맥교환

- 하나의 프로세스나 스레드가 CPU를 사용하고 있는 상태에서 다른 프로세스나 스레드가 CPU를 사용하도록 하기 위해 이전의 프로세스 상태를 보고나하고 새로운 프로세스의 상태를 적재하는 과정

## 스레드 사용하기

### 생성 방법

- class
  - Thread 클래스를 상속
- interface
  - Runnable 인터페이스를 상속
- 익명 객체
  - object 키워드를 사용
- 람다식
  - 람다식에서 사용

### 스레드풀 사용하기

- 자주 재사용되는 스레드를 이용하기 위해 미리 생성된 스레드풀에서 스레드 이용
- `val myService:ExecutorService = Executors.newFixedThreadPool([numbers])`

## 코루틴 개념

- 스레드와 달리 코루틴을 통해서 복잡성을 줄이고 손쉽게 일시 중단하거나 다시 시작하는 루틴을 만들어낼 수 있다.
- 멀티태스킹을 실현하면서 가벼운 스레드라고도 불림
- 코루틴은 문맥 교환 없이 해당 루틴을 일시 중단을 통해 제어
- 스레드 내부의 여러 루틴(routine)이 협력한다(co)

### kotlinx.coroutines 의 common 패키지

- launch / async
  - coutine builder
- job / deferred
  - cancellation 지원
- dispatchers
  - default, main, io ...
  - 디스패쳐에 따라 코루틴을 구성
- delay / yield
  - 상위 레벨 지연 함수
- channel / mutex
  - 통신과 동기화를 위한 기능
- coroutineScope / supervisorScope
  - 범위 빌더
- select
  - 표현식 지원
- commonPool
  - 코루틴 컨텍스트
- produce / actor
  - 코루틴 빌더

### 코루틴 빌더

- launch
  - 실행하고 잊어버리는 형태의 코루틴
  - 메인 프로그램과 독립되 실행할 수 있다
  - 기본적으로 즉시 실행, 실행 결과는 반환하지 않음
  - Job객체를 반환, 상위 코드를 블록시키지 않음
  - join을 통해 상위 코드가 종료되지않고 완료를 기다리게할 수 있다
- async
  - 비동기 호출을 위해 만든 코루틴, 결과나 예외를 반환
  - Deffered\<T>를 통해 반환, await을 통해 받을 수 있다
  - 작업을 완료할때까지 대기
- suspend
  - 일시정지
  - 코루틴 블록외에 사용하면 오류가 난다
  - suspend가 붙은 함수는 컴파일러가 자동적으로 추출해 Continuation 클래스로부터 분리된 루틴을 만든다
  - 코루틴 빌더인 launch와 async에서 이용할 수 있다
